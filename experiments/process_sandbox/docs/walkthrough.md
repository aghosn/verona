Walkthrough Example
-------------------

In this document, we provide a detailed walkthrough for the `test-sandbox-basic` test.
It highlights the main implementation details that allow the code to spawn an untrusted sandboxed library and safely invoke its functionality.

### Files

* [tests/sandbox-basic.cc](../tests/sandbox-basic.cc): Defines the main entry point of the test.
* [tests/sandboxlib-basic.cc](../tests/sandboxlib-basic.cc): Defines the basic library that will be sandboxed.

### Running the test

```
./build_ninja/tests/test-sandbox-basic

# expected Output

Adding 1 to 2 in sandbox
Adding 2147483647 to -1 in sandbox
Adding 1 to 2 in sandbox
Adding 2147483647 to -1 in sandbox
Adding 1 to 2 in sandbox
Adding 2147483647 to -1 in sandbox
```

### High Level Description

This tests creates 3 sandboxes wrapping around the simple adder defined by the sandboxed library.
Each sandbox runs in a separate process and is called twice.


### Runtime Walkthrough

Below is the process tree generated by the test:

```
test-sandbox-basic─┬─3*[library_runner]
                   └─{test-sandbox-basic}

```

The test creates three children processes and one thread.

* *Thread:* It is created as part of the `sandbox::Library::MemoryServiceProvider` defined in [src/libsandbox.cc](../src/libsandbox.cc) and handles pagemap updates from children.

* *Processes:* Each process runs the [library_runner](../src/library_runner.cc) which dynamically loads the sandboxed library `sandboxed-basic.so`.


#### Memory Layout

On Linux with `memfd` support, we observe the following shared memory mappings in the parent and children processes:

```
# [Parent] test-sandbox-basic 
7f8000000000-7fc000000000 rw-s 00000000 00:01 362                        /memfd:Verona Sandbox (deleted)
7ffe80000000-7ffec0000000 rw-s 00000000 00:01 7515                       /memfd:Verona Sandbox (deleted)
7fff00000000-7fff40000000 rw-s 00000000 00:01 7514                       /memfd:Verona Sandbox (deleted)
7fff80000000-7fffc0000000 rw-s 00000000 00:01 361                        /memfd:Verona Sandbox (deleted)

# [Child 1] library_runner
7fbf80000000-7fff80000000 r--s 00000000 00:01 362                        /memfd:Verona Sandbox (deleted)
7fff80000000-7fffc0000000 rw-s 00000000 00:01 361                        /memfd:Verona Sandbox (deleted)

# [Child 2] library_runner
7fbf00000000-7fff00000000 r--s 00000000 00:01 362                        /memfd:Verona Sandbox (deleted)
7fff00000000-7fff40000000 rw-s 00000000 00:01 7514                       /memfd:Verona Sandbox (deleted)

# [Child 3] library_runner
7fbe80000000-7ffe80000000 r--s 00000000 00:01 362                        /memfd:Verona Sandbox (deleted)
7ffe80000000-7ffec0000000 rw-s 00000000 00:01 7515                       /memfd:Verona Sandbox (deleted)
```

To better understand the virtual memory layout, consider the following "graphical" representation: 

```
[Parent] test-sandbox-basic                    [Child 1] library_runner                       [Child 2] library_runner                       [Child 3] library_runner
                                                                                                                                             
  |-- 0x7f8000000000 [rw-s]                                                                                                                       
  |                                                                                                                                          
  |                                                                                                                                            |-- 0x7fbe80000000 [r--s]
  |                                                                                                                                            |
  ...                                                                                           |-- 0x7fbf00000000 [r--s]                      |
  |                                                                                             |                                              |
  |                                              |-- 0x7fbf80000000 [r--s]                      |                                              |
  |                                              |                                              |                                              |        PageMap
  |-- 0x7fc000000000                             |                                              |                                              |
                                                 |                                              |        PageMap                               |
                                                 |                                              |                                              |
                                                 |        PageMap                               |                                              | 
  |-- 0x7ffe80000000 -- 0x7ffec0000000 [rw-s]    |                                              |                                              |-- child 3 region [rw-s]
                                                 |                                              |                                            
  |-- 0x7fff00000000 -- 0x7fff40000000 [rw-s]    |                                              |-- child 2 region [rw-s]                     
                                                 |                                                                                           
  |-- 0x7fff80000000 -- 0x7fffc0000000 [rw-s]    |-- child 1 region [rw-s]                                                                   

```

The `library_runner` is responsible, at initialization time, for ensuring that both the `PageMap` and the child's memory region (i.e., heap) are correctly mapped in the process's address space.
For that purposes, it uses the `memfd` file descriptors inherited from the parent.
It relies on `mmap` to install the heap as a shared memory region that is both readable and writable.
The `library_runner` opens the `memfd` file descriptor that corresponds to the `PageMap` object and maps its content read-only in the child's address space.

#### Invoking the sandbox

We follow the execution of the program and show how, on Linux, the parent invokes the `sum` function defined in [sandboxlib-basic](../tests/sandboxlib-basic.cc).


On the parent side, the sandbox library sets up a call frame containing the arguments to the function call and a return element in the shared memory region and points the `msg_buffer` field in the header of the shared memory region to this buffer.
It passes the pointer to that call frame as well as the index of the library's function invoked via shared memory to the child that it wakes up.
Simple one-bit in-memory semaphores are used to communicate with the child process.
These are implemented with the platform's low-level primitive, `futex` on Linux and `_umtx_op` on FreeBSD.
The trace below shows the parent's stack trace:

```
#0  syscall () at ../sysdeps/unix/sysv/linux/x86_64/syscall.S:38
#1  0x00007ffff7f3b611 in sandbox::platform::FutexOneBitSem::futex_op (this=0x7fff800000c0, futex_op=1, val=1, timeout=0x0) at ../include/process_sandbox/platform/onebitsem_futex.h:29
#2  0x00007ffff7f3b884 in sandbox::platform::FutexOneBitSem::wake (this=0x7fff800000c0) at ../include/process_sandbox/platform/onebitsem_futex.h:46
#3  0x00007ffff7f38d77 in sandbox::Library::send (this=0x7fffffffd1b0, idx=1, ptr=0x7fff80004020) at ../src/libsandbox.cc:774
#4  0x000055555557e0b0 in sandbox::Function<int, int, int>::operator() (this=0x7fffffffd660, args#0=1, args#1=2) at ../include/process_sandbox/cxxsandbox.h:103
#5  0x000055555557cd65 in test_sum (sb=..., a=1, b=2) at ../tests/sandbox-basic.cc:31
#6  0x000055555557cf18 in main () at ../tests/sandbox-basic.cc:40
```

The pointer to the call frame object and the function index are not used again after this point and so a reentrant call (if the child calls back into the parent, which then calls back into the child) can reuse them.
The trace below shows the child's side of the execution:

```
#4  0x00007fffefa168c0 in std::apply<int (*&)(int, int), std::tuple<int, int>&> (__f=@0x7fff800080a8: 0x7fffefa1476e <sum(int, int)>, __t=std::tuple containing = {...}) at /usr/include/c++/10/tuple:1738
#5  0x00007fffefa16923 in sandbox::ExportedFunction<int, int, int>::operator() (this=0x7fff800080a0, callframe=0x7fff80004020) at ../include/process_sandbox/cxxsandbox.h:176
#6  0x00007fffefa14ab7 in sandbox::ExportedLibrary::call (idx=1, args=0x7fff80004020) at ../include/process_sandbox/cxxsandbox.h:217
#7  0x00007fffefa1476b in sandbox::sandbox_call (idx=1, args=0x7fff80004020) at ../include/process_sandbox/cxxsandbox.h:249
#8  0x000055555559eaed in (anonymous namespace)::runloop (callback_depth=0) at ../src/library_runner.cc:295
#9  0x00005555555a001e in runloop_with_stack_pivot () at ../src/library_runner.cc:807
```
